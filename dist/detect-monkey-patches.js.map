{"version":3,"file":"detect-monkey-patches.js","mappings":"sCAIA,SAAgBA,EAASC,EAAkBC,GAGzC,IAA8C,IAA1CA,EAAQC,QAAQ,qBAA6B,OAAO,EAGxD,GAAID,KAAY,IAAAE,cAAaH,GAAW,OAAO,EAK/C,IAAMI,EAAe,CACnB,CAAC,OAAQ,SACT,CAAC,QAAS,OACV,CAAC,OAAQ,UACT,CAAC,cAAe,gBAGdC,GAAkB,EAEtB,IAAK,IAAIC,KAAKF,EAAc,CACpB,MAAoBA,EAAaE,GAAhCC,EAAQ,KAAEC,EAAK,KAKhBC,GAHYT,EAASU,QAAQH,EAAUC,GACxBR,EAASU,QAAQF,EAAOD,IAE5B,IAAAJ,cAAaH,EAASU,QAAQH,EAAUC,KACnDG,GAAc,IAAAR,cAAaH,EAASU,QAAQF,EAAOD,IAEzD,GAAIE,IAAaR,GAAWU,IAAgBV,EAAS,CACnDI,GAAkB,EAClB,KACF,CACF,CAEA,OAAOA,CACT,C,mGApCA,aA0CA,6BAAkCO,GAGhC,IAAMC,EAAaC,OAAOF,GAEpBG,EAA0C,GAEhD,IAAKF,EAAWG,UAAW,MAAO,GAElC,IAAMC,EAAQC,OAAOC,oBAAoBN,EAAWG,WAEpD,IAAK,IAAII,KAAYH,EAAO,CAC1B,IAAMjB,EAAWiB,EAAMG,GAIvB,IAIE,GAAiB,mBAHOP,EAAWG,UAAUhB,GAGhB,SAE7B,IAAMC,EAAUY,EAAWG,UAAUhB,GAAUqB,WAO/C,GAAgB,gBAAbrB,EAED,SAGmBD,EAASC,EAAUC,IAItCc,EAAmBO,KAAK,CAACtB,EAAUC,GAGvC,CAAE,MAAOsB,GACP,QACF,CACF,CAEA,OAAOR,CACT,EA3Fa,EAAAZ,aAAe,SAACH,GAAqB,yBAAYA,EAAQ,uBAApB,EA+FrC,EAAAwB,0BAA4B,SAACC,GACxCA,EAAMC,gBACR,C,GClGIC,EAA2B,CAAC,EAGhC,SAASC,EAAoBC,GAE5B,IAAIC,EAAeH,EAAyBE,GAC5C,QAAqBE,IAAjBD,EACH,OAAOA,EAAaE,QAGrB,IAAIC,EAASN,EAAyBE,GAAY,CAGjDG,QAAS,CAAC,GAOX,OAHAE,EAAoBL,GAAUI,EAAQA,EAAOD,QAASJ,GAG/CK,EAAOD,OACf,C,MCtBA,aAEAG,YAAYC,KAAK,SAEjBtB,OAAOuB,iBAAiB,qBAAsB,EAAAb,2BAG9C,IAAMc,EAAcpB,OAAOC,oBAAoBL,QACzCyB,EAA4B,CAAC,EAEnC,IAAK,IAAIC,KAAQF,EAAa,CAC5B,IAAMlB,EAAWkB,EAAYE,GAG7B,GAAI,QAAQC,KAAKrB,EAAS,IAAK,CAC7B,IAAMsB,GAAM,IAAAC,mBAAkBvB,GAE1BsB,EAAIE,SACNL,EAAanB,GAAYsB,EAE7B,CACF,CAIAG,YAAW,WACT/B,OAAOgC,oBAAoB,qBAAsB,EAAAtB,0BACnD,GAAG,GAEHW,YAAYC,KAAK,OAEjBW,QAAQC,IACNT,EACAJ,YAAYc,QAAQ,eAAgB,QAAS,OAAOC,SACpD,K","sources":["webpack://detect-monkey-patches/./src/helpers.ts","webpack://detect-monkey-patches/webpack/bootstrap","webpack://detect-monkey-patches/./src/index.ts"],"sourcesContent":["\r\n\r\nexport const getNativeDef = (funcName: string) => `function ${funcName}() { [native code] }`;\r\n\r\nexport function isNative(funcName: string, funcDef: string) {\r\n  // if the definition doesnt even contain \"native code\" then it's not native\r\n  // no need to check synonyms\r\n  if (funcDef.indexOf(\"{ [native code] }\") === -1) return false;\r\n\r\n  // definition matches function name exactly\r\n  if (funcDef === getNativeDef(funcName)) return true;\r\n\r\n  // sometimes native functions will alias others\r\n  // eg: trimRight => trimEnd\r\n  // eg: trimLeft => trimStart\r\n  const knownAliases = [\r\n    [\"Left\", \"Start\"],\r\n    [\"Right\", \"End\"],\r\n    [\"keys\", \"values\"],\r\n    [\"toGMTString\", \"toUTCString\"]\r\n  ];\r\n\r\n  let synonymIsNative = false;\r\n\r\n  for (let a in knownAliases) {\r\n    const [original, alias] = knownAliases[a];\r\n\r\n    const aliasName = funcName.replace(original, alias);\r\n    const aliasNameRev = funcName.replace(alias, original);\r\n\r\n    const aliasDef = getNativeDef(funcName.replace(original, alias));\r\n    const aliasDefRev = getNativeDef(funcName.replace(alias, original));\r\n\r\n    if (aliasDef === funcDef || aliasDefRev === funcDef) {\r\n      synonymIsNative = true;\r\n      break;\r\n    }\r\n  }\r\n\r\n  return synonymIsNative;\r\n}\r\n\r\nexport interface FakeType {\r\n  prototype: Record<string, { toString: () => string }>\r\n};\r\n\r\nexport function findMonkeyPatches(nativeTypeName: string): Array<Array<string>> {\r\n\r\n  // fix this with correct types\r\n  const nativeType = window[nativeTypeName as unknown as number] as unknown as FakeType;\r\n\r\n  const foundMonkeyPatches:Array<Array<string>> = [];\r\n\r\n  if (!nativeType.prototype) return [];\r\n\r\n  const props = Object.getOwnPropertyNames(nativeType.prototype);\r\n\r\n  for (let propName in props) {\r\n    const funcName = props[propName];\r\n\r\n    // wrap in try-catch to avoid breaking the loop\r\n    // for \"illegal invocation\" errors\r\n    try {\r\n      const propType = typeof nativeType.prototype[funcName];\r\n\r\n      // we're only testing functions\r\n      if (propType !== \"function\") continue;\r\n\r\n      const funcDef = nativeType.prototype[funcName].toString();\r\n\r\n      // check the constructor against its type name\r\n      // if (funcName === \"constructor\" && !isNative(nativeTypeName, funcDef)) {\r\n      //   foundMonkeyPatches.push([funcName, funcDef]);\r\n      //   continue;\r\n      // }\r\n      if(funcName === \"constructor\")\r\n      {\r\n        continue\r\n      }\r\n\r\n      const funcIsNative = isNative(funcName, funcDef);\r\n\r\n      //console.log({ funcName, funcDef, funcIsNative, nativeTypeName })\r\n      if (!funcIsNative) {\r\n        foundMonkeyPatches.push([funcName, funcDef]);\r\n      }\r\n\r\n    } catch (e) {\r\n      continue;\r\n    }\r\n  }\r\n\r\n  return foundMonkeyPatches;\r\n}\r\n\r\n// if a property is a rejected promise and we touch it, it will throw an error\r\n// so suppress the event while we work\r\nexport const suppressPromiseRejections = (event: Event) => {\r\n  event.preventDefault();\r\n};","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import {suppressPromiseRejections,findMonkeyPatches} from './helpers'\r\n\r\nperformance.mark(\"start\");\r\n\r\nwindow.addEventListener(\"unhandledrejection\", suppressPromiseRejections);\r\n\r\ntype PatchedProps = Record<string,Array<Array<string>>>\r\nconst windowProps = Object.getOwnPropertyNames(window);\r\nconst patchedProps:PatchedProps = {}\r\n\r\nfor (let prop in windowProps) {\r\n  const propName = windowProps[prop];\r\n\r\n  // we're only interested in types\r\n  if (/[A-Z]/.test(propName[0])) {\r\n    const mps = findMonkeyPatches(propName);\r\n\r\n    if (mps.length) {\r\n      patchedProps[propName] = mps\r\n    }\r\n  }\r\n}\r\n\r\n// remove the suppression after we're done\r\n// 1ms timeout to make the call async else it gets removed before the Promises actually reject\r\nsetTimeout(() => {\r\n  window.removeEventListener(\"unhandledrejection\", suppressPromiseRejections);\r\n}, 1);\r\n\r\nperformance.mark(\"end\");\r\n\r\nconsole.log(\r\n  patchedProps,\r\n  performance.measure(\"start to end\", \"start\", \"end\").duration,\r\n  \"ms\"\r\n);\r\n"],"names":["isNative","funcName","funcDef","indexOf","getNativeDef","knownAliases","synonymIsNative","a","original","alias","aliasDef","replace","aliasDefRev","nativeTypeName","nativeType","window","foundMonkeyPatches","prototype","props","Object","getOwnPropertyNames","propName","toString","push","e","suppressPromiseRejections","event","preventDefault","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","performance","mark","addEventListener","windowProps","patchedProps","prop","test","mps","findMonkeyPatches","length","setTimeout","removeEventListener","console","log","measure","duration"],"sourceRoot":""}