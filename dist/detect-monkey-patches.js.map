{"version":3,"file":"detect-monkey-patches.js","mappings":"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","sources":["webpack://detect-monkey-patches/./src/helpers.ts","webpack://detect-monkey-patches/webpack/bootstrap","webpack://detect-monkey-patches/./src/index.ts"],"sourcesContent":["\r\n\r\nexport const getNativeDef = (funcName: string) => `function ${funcName}() { [native code] }`;\r\n\r\nexport function isNative(funcName: string, funcDef: string) {\r\n  // if the definition doesnt even contain \"native code\" then it's not native\r\n  // no need to check synonyms\r\n  if (funcDef.indexOf(\"{ [native code] }\") === -1) return false;\r\n\r\n  // definition matches function name exactly\r\n  if (funcDef === getNativeDef(funcName)) return true;\r\n\r\n  // sometimes native functions will alias others\r\n  // eg: trimRight => trimEnd\r\n  // eg: trimLeft => trimStart\r\n  const knownAliases = [\r\n    [\"Left\", \"Start\"],\r\n    [\"Right\", \"End\"],\r\n    [\"keys\", \"values\"],\r\n    [\"toGMTString\", \"toUTCString\"]\r\n  ];\r\n\r\n  let aliasIsNative = false;\r\n\r\n  for (let a in knownAliases) {\r\n    const [original, alias] = knownAliases[a];\r\n\r\n    const aliasDef = getNativeDef(funcName.replace(original, alias));\r\n    const aliasDefRev = getNativeDef(funcName.replace(alias, original));\r\n\r\n    if (aliasDef === funcDef || aliasDefRev === funcDef) {\r\n      aliasIsNative = true;\r\n      break;\r\n    }\r\n  }\r\n\r\n  return aliasIsNative;\r\n}\r\n\r\nexport interface FakeType {\r\n  prototype: Record<string, { toString: () => string }>\r\n};\r\n\r\nexport type MonkeyPatches = Array<Array<string>>\r\n\r\nexport type PatchedProps = Record<string,MonkeyPatches>\r\n\r\nexport function findMonkeyPatches(nativeTypeName: string): MonkeyPatches {\r\n\r\n  // fix this with correct types\r\n  const nativeType = window[nativeTypeName as unknown as number] as unknown as FakeType;\r\n\r\n  const foundMonkeyPatches:MonkeyPatches = [];\r\n\r\n  if (!nativeType.prototype) return [];\r\n\r\n  const props = Object.getOwnPropertyNames(nativeType.prototype);\r\n\r\n  for (let propName in props) {\r\n    const funcName = props[propName];\r\n\r\n    // wrap in try-catch to avoid breaking the loop\r\n    // for \"illegal invocation\" errors\r\n    try {\r\n      const propType = typeof nativeType.prototype[funcName];\r\n\r\n      // we're only testing functions\r\n      if (propType !== \"function\") continue;\r\n\r\n      const funcDef = nativeType.prototype[funcName].toString();\r\n\r\n      // check the constructor against its type name\r\n      // if (funcName === \"constructor\" && !isNative(nativeTypeName, funcDef)) {\r\n      //   foundMonkeyPatches.push([funcName, funcDef]);\r\n      //   continue;\r\n      // }\r\n      if(funcName === \"constructor\")\r\n      {\r\n        continue\r\n      }\r\n\r\n      const funcIsNative = isNative(funcName, funcDef);\r\n\r\n      //console.log({ funcName, funcDef, funcIsNative, nativeTypeName })\r\n      if (!funcIsNative) {\r\n        foundMonkeyPatches.push([funcName, funcDef]);\r\n      }\r\n\r\n    } catch (e) {\r\n      continue;\r\n    }\r\n  }\r\n\r\n  return foundMonkeyPatches;\r\n}\r\n\r\n// if a property is a rejected promise and we touch it, it will throw an error\r\n// so suppress the event while we work\r\nexport const suppressPromiseRejections = (event: Event) => {\r\n  event.preventDefault();\r\n};","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","import {suppressPromiseRejections,findMonkeyPatches} from './helpers'\r\nimport type {MonkeyPatches,PatchedProps} from './helpers'\r\n\r\n/**\r\n * TODO\r\n * 1. move performance tests to separate place\r\n * 2. add a fix() function that opens a blank iframe to grab the native definition \r\n * 3. main function should return a promise with the results so user can be \r\n *      sure they act after the unhandledrejection handler removed\r\n * 4. flesh out README\r\n * 5. jest tests\r\n */\r\nperformance.mark(\"start\");\r\n\r\nexport function detectMonkeyPatches():Promise<PatchedProps> {\r\n  return new Promise((resolve) => {\r\n\r\n    window.addEventListener(\"unhandledrejection\", suppressPromiseRejections);\r\n    \r\n    const windowProps = Object.getOwnPropertyNames(window);\r\n    const patchedProps:PatchedProps = {}\r\n    \r\n    for (let prop in windowProps) {\r\n      const propName = windowProps[prop];\r\n    \r\n      // we're only interested in types\r\n      if (/[A-Z]/.test(propName[0])) {\r\n        const mps = findMonkeyPatches(propName);\r\n    \r\n        if (mps.length) {\r\n          patchedProps[propName] = mps\r\n        }\r\n      }\r\n    }\r\n    \r\n    // remove the suppression after we're done\r\n    // 1ms timeout to make the call async else it gets removed before the Promises actually reject\r\n    setTimeout(() => {\r\n      window.removeEventListener(\"unhandledrejection\", suppressPromiseRejections);\r\n      resolve(patchedProps)\r\n    }, 1);\r\n  })\r\n}\r\n\r\nif(!window.hasOwnProperty('detectMonkeyPatches'))\r\n{  \r\n  Object.defineProperty(window,'detectMonkeyPatches',{\r\n    value : detectMonkeyPatches\r\n  })\r\n}\r\n\r\n// performance.mark(\"end\");\r\n\r\n// console.log(\r\n//   patchedProps,\r\n//   performance.measure(\"start to end\", \"start\", \"end\").duration,\r\n//   \"ms\"\r\n// );\r\n"],"names":[],"sourceRoot":""}